#!/usr/bin/env python3

import curses
import os
from pathlib import Path
import shutil
from enum import Enum
from datetime import datetime, timedelta
import tempfile
import sys
import json
import subprocess
import threading
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from urllib.parse import urlparse

class View(Enum):
    GENERAL = "general"    # User level (~/.claude/agents)
    PROJECT = "project"    # Project level (.claude/agents)
    SOURCES = "sources"    # Sources management

@dataclass
class AgentSource:
    """Represents an agent source configuration"""
    id: str
    name: str
    url: str
    path: str = "agents-collection"
    enabled: bool = True
    priority: int = 50
    last_sync: Optional[str] = None
    branch: str = "main"
    readonly: bool = True
    source_type: str = "git"  # git, local, http
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AgentSource':
        return cls(**data)

@dataclass 
class SourcesConfig:
    """Configuration for the sources system"""
    version: str = "1.0"
    sources: List[AgentSource] = None
    auto_sync: bool = True
    sync_interval: int = 86400  # 24 hours
    last_auto_sync: Optional[str] = None
    
    def __post_init__(self):
        if self.sources is None:
            # Default source - our repository
            self.sources = [
                AgentSource(
                    id="default",
                    name="Claude Agent Manager Official",
                    url="https://github.com/GailenTech/claude-agent-manager.git",
                    path="agents-collection",
                    enabled=True,
                    priority=100,
                    readonly=False
                )
            ]
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "version": self.version,
            "sources": [source.to_dict() for source in self.sources],
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
            "last_auto_sync": self.last_auto_sync
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SourcesConfig':
        sources = [AgentSource.from_dict(s) for s in data.get('sources', [])]
        return cls(
            version=data.get('version', '1.0'),
            sources=sources,
            auto_sync=data.get('auto_sync', True),
            sync_interval=data.get('sync_interval', 86400),
            last_auto_sync=data.get('last_auto_sync')
        )

class SourcesManager:
    """Manages agent sources - loading, syncing, caching"""
    
    def __init__(self):
        self.config_dir = Path.home() / ".config" / "claude-agent-manager"
        self.cache_dir = Path.home() / ".cache" / "claude-agent-manager" / "sources"
        self.config_file = self.config_dir / "sources.json"
        
        # Ensure directories exist
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        self.config: Optional[SourcesConfig] = None
        self.load_config()
    
    def load_config(self) -> SourcesConfig:
        """Load sources configuration from file"""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    data = json.load(f)
                self.config = SourcesConfig.from_dict(data)
            except (json.JSONDecodeError, KeyError) as e:
                print(f"Error loading sources config: {e}")
                self.config = SourcesConfig()
                self.save_config()
        else:
            self.config = SourcesConfig()
            self.save_config()
        
        return self.config
    
    def save_config(self):
        """Save sources configuration to file"""
        with open(self.config_file, 'w') as f:
            json.dump(self.config.to_dict(), f, indent=2)
    
    def get_enabled_sources(self) -> List[AgentSource]:
        """Get list of enabled sources sorted by priority (descending)"""
        enabled = [s for s in self.config.sources if s.enabled]
        return sorted(enabled, key=lambda x: x.priority, reverse=True)
    
    def add_source(self, source: AgentSource) -> bool:
        """Add a new source"""
        # Check if ID already exists
        if any(s.id == source.id for s in self.config.sources):
            return False
        
        self.config.sources.append(source)
        self.save_config()
        return True
    
    def remove_source(self, source_id: str) -> bool:
        """Remove a source by ID"""
        original_count = len(self.config.sources)
        self.config.sources = [s for s in self.config.sources if s.id != source_id]
        
        if len(self.config.sources) < original_count:
            # Also remove cached data
            cache_path = self.cache_dir / source_id
            if cache_path.exists():
                shutil.rmtree(cache_path)
            
            self.save_config()
            return True
        return False
    
    def toggle_source(self, source_id: str) -> Optional[bool]:
        """Toggle source enabled/disabled state. Returns new state or None if not found"""
        for source in self.config.sources:
            if source.id == source_id:
                source.enabled = not source.enabled
                self.save_config()
                return source.enabled
        return None
    
    def get_source_cache_path(self, source_id: str) -> Path:
        """Get cache path for a source"""
        return self.cache_dir / source_id
    
    def sync_source(self, source_id: str, progress_callback=None) -> bool:
        """Sync a single source"""
        source = next((s for s in self.config.sources if s.id == source_id), None)
        if not source:
            return False
        
        cache_path = self.get_source_cache_path(source_id)
        
        try:
            if source.source_type == "git":
                return self._sync_git_source(source, cache_path, progress_callback)
            elif source.source_type == "local":
                return self._sync_local_source(source, cache_path, progress_callback)
            # TODO: Add HTTP source support
            
        except Exception as e:
            if progress_callback:
                progress_callback(f"Error syncing {source.name}: {e}")
            return False
        
        return False
    
    def _sync_git_source(self, source: AgentSource, cache_path: Path, progress_callback=None) -> bool:
        """Sync a git-based source"""
        if progress_callback:
            progress_callback(f"Syncing {source.name}...")
        
        try:
            if cache_path.exists():
                # Update existing repo
                result = subprocess.run([
                    'git', '-C', str(cache_path), 'pull', 'origin', source.branch
                ], capture_output=True, text=True, timeout=60)
                
                if result.returncode != 0:
                    if progress_callback:
                        progress_callback(f"Git pull failed: {result.stderr}")
                    return False
            else:
                # Clone new repo
                cache_path.parent.mkdir(parents=True, exist_ok=True)
                result = subprocess.run([
                    'git', 'clone', '--depth', '1', '--branch', source.branch, 
                    source.url, str(cache_path)
                ], capture_output=True, text=True, timeout=120)
                
                if result.returncode != 0:
                    if progress_callback:
                        progress_callback(f"Git clone failed: {result.stderr}")
                    return False
            
            # Update last sync time
            source.last_sync = datetime.now().isoformat()
            self.save_config()
            
            if progress_callback:
                progress_callback(f"✓ {source.name} synced successfully")
            
            return True
            
        except subprocess.TimeoutExpired:
            if progress_callback:
                progress_callback(f"Timeout syncing {source.name}")
            return False
        except Exception as e:
            if progress_callback:
                progress_callback(f"Error syncing {source.name}: {e}")
            return False
    
    def _sync_local_source(self, source: AgentSource, cache_path: Path, progress_callback=None) -> bool:
        """Sync a local directory source"""
        if progress_callback:
            progress_callback(f"Syncing local source {source.name}...")
        
        local_path = Path(source.url)
        if not local_path.exists():
            if progress_callback:
                progress_callback(f"Local path not found: {local_path}")
            return False
        
        try:
            # Copy local directory to cache
            if cache_path.exists():
                shutil.rmtree(cache_path)
            
            shutil.copytree(local_path / source.path, cache_path, dirs_exist_ok=True)
            
            source.last_sync = datetime.now().isoformat()
            self.save_config()
            
            if progress_callback:
                progress_callback(f"✓ {source.name} synced successfully")
            
            return True
            
        except Exception as e:
            if progress_callback:
                progress_callback(f"Error syncing {source.name}: {e}")
            return False
    
    def get_merged_agents_collection(self) -> Path:
        """Get a merged view of all enabled sources"""
        # For now, return the highest priority source
        # TODO: Implement proper merging with conflict resolution
        sources = self.get_enabled_sources()
        if not sources:
            return Path("agents-collection")  # Fallback to embedded
        
        highest_priority = sources[0]
        cache_path = self.get_source_cache_path(highest_priority.id)
        
        if cache_path.exists():
            agents_path = cache_path / highest_priority.path
            if agents_path.exists():
                return agents_path
        
        # Fallback to embedded collection
        return Path("agents-collection")
    
    def sync_all_sources(self, progress_callback=None) -> Dict[str, bool]:
        """Sync all enabled sources"""
        results = {}
        for source in self.get_enabled_sources():
            results[source.id] = self.sync_source(source.id, progress_callback)
        return results

class TreeNode:
    def __init__(self, name, path, is_folder=False, level=0):
        self.name = name
        self.path = path
        self.is_folder = is_folder
        self.level = level
        self.expanded = level < 2  # Auto-expand first 2 levels
        self.children = []
        self.parent = None
        self.selected = False
        self.installed = False
        self.description = ""
        self.is_new = False
        self.agent_count = 0  # For folders
        self.changes_summary = {'add': 0, 'remove': 0}  # Track changes in folder
        
    def get_display_name(self):
        """Get display name with folder indicators"""
        if self.is_folder:
            if self.expanded:
                prefix = "▼ "
            else:
                prefix = "▶ "
            
            if self.agent_count > 0:
                return f"{prefix}{self.name.upper() if self.level == 0 else self.name}"
            else:
                return f"{prefix}{self.name.upper() if self.level == 0 else self.name}"
        else:
            return self.name
    
    def get_agent_count_recursive(self):
        """Count all agents in this folder and subfolders"""
        if not self.is_folder:
            return 1
        
        count = 0
        for child in self.children:
            if child.is_folder:
                count += child.get_agent_count_recursive()
            else:
                count += 1
        return count
    
    def toggle_expand(self):
        """Toggle folder expansion"""
        if self.is_folder:
            self.expanded = not self.expanded
    
    def update_changes_summary(self, changes_dict):
        """Update changes summary for this node and propagate to parents"""
        if not self.is_folder:
            return
        
        # Reset counters
        self.changes_summary = {'add': 0, 'remove': 0}
        
        # Count changes in direct children and subfolders
        for child in self.children:
            if child.is_folder:
                # Recursively update child folders first
                child.update_changes_summary(changes_dict)
                # Add child folder's changes to this folder
                self.changes_summary['add'] += child.changes_summary['add']
                self.changes_summary['remove'] += child.changes_summary['remove']
            else:
                # Check if this agent has changes
                relative_path = str(child.path.relative_to(child.path.parent.parent.parent)) if child.path.parent.parent.parent.exists() else child.name
                for key, change_type in changes_dict.items():
                    if change_type and child.name in key:
                        if change_type == 'add':
                            self.changes_summary['add'] += 1
                        elif change_type == 'remove':
                            self.changes_summary['remove'] += 1
    
    def get_changes_display(self):
        """Get formatted string for changes display"""
        if not self.is_folder or (self.changes_summary['add'] == 0 and self.changes_summary['remove'] == 0):
            return ""
        
        parts = []
        if self.changes_summary['add'] > 0:
            parts.append(f"+{self.changes_summary['add']}")
        if self.changes_summary['remove'] > 0:
            parts.append(f"-{self.changes_summary['remove']}")
        
        return f" [{' '.join(parts)}]" if parts else ""

class AgentManagerTree:
    def __init__(self):
        self.script_dir = Path(__file__).parent.absolute()
        
        # Initialize sources manager
        self.sources_manager = SourcesManager()
        
        # Get agents collection from sources or fallback to embedded
        collection_path = os.environ.get('CLAUDE_AGENT_COLLECTION')
        if collection_path:
            self.agents_collection = Path(collection_path)
        else:
            # Try to use merged sources collection, fallback to embedded
            try:
                self.agents_collection = self.sources_manager.get_merged_agents_collection()
                if not self.agents_collection.exists():
                    self.agents_collection = self.script_dir / "agents-collection"
            except:
                self.agents_collection = self.script_dir / "agents-collection"
        
        self.user_agents = Path.home() / ".claude" / "agents"
        self.project_root = self.detect_project()
        self.project_agents = self.project_root / ".claude" / "agents" if self.project_root else None
        
        self.current_view = View.GENERAL
        self.current_index = 0
        self.tree_root = TreeNode("root", self.agents_collection, is_folder=True, level=-1)
        self.flattened_nodes = []
        self.original_state = {}
        self.current_state = {}
        self.changes = {}
        
        # Sources view state
        self.sources_index = 0
        self.sources_status_messages = []
        self.sync_in_progress = False
        
        # Check for auto-sync on startup
        self.check_auto_sync_on_startup()
        
        self.build_tree()
        self.load_installation_state()
        self.flatten_tree()
    
    def detect_project(self):
        """Detect git project root"""
        current = Path.cwd()
        while current != current.parent:
            if (current / ".git").exists():
                return current
            current = current.parent
        return None
    
    def is_new_agent(self, file_path):
        """Check if agent file was created in last 48 hours"""
        try:
            mtime = file_path.stat().st_mtime
            age = datetime.now() - datetime.fromtimestamp(mtime)
            return age < timedelta(hours=48)
        except:
            return False
    
    def get_agent_info(self, file_path):
        """Extract agent description from file"""
        desc = "No description"
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    if line.startswith('description:'):
                        desc = line.replace('description:', '').strip()[:60]
                        break
        except:
            pass
        return desc
    
    def build_tree(self):
        """Build tree structure from agents collection"""
        self.tree_root.children = []
        self._build_tree_recursive(self.agents_collection, self.tree_root, 0)
        
        # Update agent counts
        for child in self.tree_root.children:
            child.agent_count = child.get_agent_count_recursive()
    
    def _build_tree_recursive(self, path, parent_node, level):
        """Recursively build tree from filesystem"""
        try:
            items = sorted(path.iterdir())
            
            # First add subdirectories
            for item in items:
                if item.is_dir() and not item.name.startswith('.'):
                    folder_node = TreeNode(item.name, item, is_folder=True, level=level)
                    folder_node.parent = parent_node
                    parent_node.children.append(folder_node)
                    
                    # Recurse into subdirectory
                    self._build_tree_recursive(item, folder_node, level + 1)
            
            # Then add .md files
            for item in items:
                if item.is_file() and item.suffix == '.md':
                    agent_node = TreeNode(item.stem, item, is_folder=False, level=level)
                    agent_node.parent = parent_node
                    agent_node.description = self.get_agent_info(item)
                    agent_node.is_new = self.is_new_agent(item)
                    parent_node.children.append(agent_node)
                    
        except PermissionError:
            pass
    
    def load_installation_state(self):
        """Load which agents are installed"""
        check_dir = self.user_agents if self.current_view == View.GENERAL else self.project_agents
        
        self.original_state = {}
        self.current_state = {}
        self.changes = {}
        
        if check_dir and check_dir.exists():
            installed_files = set(f.stem for f in check_dir.glob("*.md"))
        else:
            installed_files = set()
        
        # Mark installed agents in tree
        self._mark_installed_recursive(self.tree_root, installed_files)
        
        # Reset all change summaries when switching views
        self._reset_all_changes_summary(self.tree_root)
    
    def _mark_installed_recursive(self, node, installed_files):
        """Recursively mark installed agents"""
        if not node.is_folder:
            node.installed = node.name in installed_files
            node.selected = node.installed
            
            # Track state
            key = str(node.path.relative_to(self.agents_collection))
            self.original_state[key] = node.installed
            self.current_state[key] = node.installed
            self.changes[key] = None
        else:
            for child in node.children:
                self._mark_installed_recursive(child, installed_files)
    
    def _reset_all_changes_summary(self, node):
        """Reset change summaries for all folders"""
        if node.is_folder:
            node.changes_summary = {'add': 0, 'remove': 0}
            for child in node.children:
                self._reset_all_changes_summary(child)
    
    def flatten_tree(self):
        """Flatten tree to list for display, respecting expansion state"""
        self.flattened_nodes = []
        self._flatten_recursive(self.tree_root)
    
    def _flatten_recursive(self, node):
        """Recursively flatten tree"""
        # Don't include root node itself
        if node.level >= 0:
            self.flattened_nodes.append(node)
        
        # Only include children if folder is expanded or if it's root
        if node.is_folder and (node.expanded or node.level == -1):
            for child in node.children:
                self._flatten_recursive(child)
    
    def toggle_selection(self, node):
        """Toggle agent selection and track changes"""
        if node.is_folder:
            return
        
        node.selected = not node.selected
        
        key = str(node.path.relative_to(self.agents_collection))
        self.current_state[key] = node.selected
        
        if self.current_state[key] == self.original_state[key]:
            self.changes[key] = None
        elif self.current_state[key]:
            self.changes[key] = 'add'
        else:
            self.changes[key] = 'remove'
        
        # Update changes summary for all folders
        self.update_all_changes_summary()
    
    def update_all_changes_summary(self):
        """Update changes summary for entire tree"""
        for child in self.tree_root.children:
            child.update_changes_summary(self.changes)
    
    def get_changes_summary(self):
        """Get summary of pending changes"""
        adds = [Path(k).name for k, v in self.changes.items() if v == 'add']
        removes = [Path(k).name for k, v in self.changes.items() if v == 'remove']
        return adds, removes
    
    def save_changes(self):
        """Apply all changes to filesystem"""
        target_dir = self.user_agents if self.current_view == View.GENERAL else self.project_agents
        target_dir.mkdir(parents=True, exist_ok=True)
        
        for path_key, change in self.changes.items():
            if change is None:
                continue
            
            source_file = self.agents_collection / path_key
            agent_name = Path(path_key).stem
            target_file = target_dir / f"{agent_name}.md"
            
            if change == 'add' and source_file.exists():
                shutil.copy2(source_file, target_file)
            elif change == 'remove' and target_file.exists():
                target_file.unlink()
        
        # Reload state
        self.load_installation_state()
        self.flatten_tree()
    
    def view_agent_file(self, node):
        """View agent file in read-only mode"""
        if node.is_folder or not node.path.exists():
            return
        
        editor = os.environ.get('PAGER', 'less')
        if not shutil.which(editor):
            editor = 'cat'
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as tmp:
            tmp.write(f"# VIEWING (READ-ONLY): {node.name}\n")
            tmp.write(f"# Path: {node.path.relative_to(self.agents_collection)}\n")
            tmp.write(f"# {'=' * 60}\n\n")
            with open(node.path, 'r') as original:
                tmp.write(original.read())
            tmp_path = tmp.name
        
        curses.endwin()
        os.system(f"{editor} {tmp_path}")
        os.unlink(tmp_path)
        curses.doupdate()
    
    def draw_header(self, stdscr, height, width):
        """Draw header with view indicator and path"""
        # Choose color based on view
        if self.current_view == View.GENERAL:
            header_color = curses.color_pair(2)  # Blue for General
            view_text = "Vista General (Usuario)"
            target_path = str(self.user_agents)
        elif self.current_view == View.PROJECT:
            header_color = curses.color_pair(3)  # Green for Project
            view_text = f"Vista Proyecto: {self.project_root.name}"
            target_path = str(self.project_agents)
        else:  # View.SOURCES
            header_color = curses.color_pair(5)  # Cyan for Sources
            view_text = "Gestión de Fuentes"
            enabled_count = len(self.sources_manager.get_enabled_sources())
            total_count = len(self.sources_manager.config.sources)
            target_path = f"{enabled_count}/{total_count} fuentes activas"
        
        # Truncate path if needed
        max_path_len = width - 10
        if len(target_path) > max_path_len:
            display_path = "..." + target_path[-(max_path_len-3):]
        else:
            display_path = target_path
        
        stdscr.addstr(0, 0, "╔" + "═" * (width-2) + "╗", header_color | curses.A_BOLD)
        stdscr.addstr(1, 0, "║", header_color | curses.A_BOLD)
        stdscr.addstr(1, width-1, "║", header_color | curses.A_BOLD)
        
        title = f"Claude Agent Manager - {view_text}"
        title_x = (width - len(title)) // 2
        stdscr.addstr(1, title_x, title, header_color | curses.A_BOLD)
        
        stdscr.addstr(2, 0, "║", header_color | curses.A_BOLD)
        stdscr.addstr(2, width-1, "║", header_color | curses.A_BOLD)
        
        # Show path on second line
        path_x = (width - len(display_path)) // 2
        stdscr.addstr(2, path_x, display_path, header_color)
        
        stdscr.addstr(3, 0, "╚" + "═" * (width-2) + "╝", header_color | curses.A_BOLD)
        
        
        adds, removes = self.get_changes_summary()
        if adds or removes:
            changes_text = "Cambios: "
            if adds:
                changes_text += f"+{len(adds)} "
            if removes:
                changes_text += f"-{len(removes)}"
            stdscr.addstr(4, 2, changes_text, curses.color_pair(4) | curses.A_BOLD)
        
        # Show sync status if in progress
        if self.sync_in_progress:
            sync_text = "🔄 Sincronizando fuentes..."
            stdscr.addstr(4, width - len(sync_text) - 2, sync_text, curses.color_pair(4))
    
    def draw_tree(self, stdscr, height, width):
        """Draw tree with proper indentation"""
        start_y = 6
        visible_height = height - 8
        
        # Calculate visible range
        if self.current_index >= visible_height:
            scroll_offset = self.current_index - visible_height + 1
        else:
            scroll_offset = 0
        
        visible_end = min(len(self.flattened_nodes), scroll_offset + visible_height)
        
        y = start_y
        for i in range(scroll_offset, visible_end):
            node = self.flattened_nodes[i]
            
            # Indentation
            indent = "  " * node.level
            
            # Selection marker
            if i == self.current_index:
                marker = "▶ "
                attr = curses.A_REVERSE
            else:
                marker = "  "
                attr = 0
            
            # Build display string
            if node.is_folder:
                # Folder display
                display_name = node.get_display_name()
                if node.agent_count > 0:
                    count_text = f" ({node.agent_count} agentes)"
                else:
                    count_text = " (vacío)"
                
                # Add changes summary if any
                changes_text = node.get_changes_display()
                
                line = f"{marker}{indent}{display_name}{count_text}{changes_text}"
                
                # Use different color for top-level folders
                if node.level == 0:
                    color = curses.color_pair(5) | curses.A_BOLD
                else:
                    color = curses.color_pair(6)
                
                # Apply change colors to the changes part
                if changes_text:
                    base_line = f"{marker}{indent}{display_name}{count_text}"
                    stdscr.addstr(y, 0, base_line[:width-len(changes_text)-1], color | attr)
                    
                    # Color the changes part
                    if node.changes_summary['add'] > 0 and node.changes_summary['remove'] > 0:
                        change_color = curses.color_pair(4)  # Yellow for mixed
                    elif node.changes_summary['add'] > 0:
                        change_color = curses.color_pair(3)  # Green for adds
                    else:
                        change_color = curses.color_pair(1)  # Red for removes
                    
                    stdscr.addstr(y, len(base_line), changes_text, change_color | attr)
                else:
                    stdscr.addstr(y, 0, line[:width-1], color | attr)
                
            else:
                # Agent display
                checkbox = "[✓] " if node.selected else "[ ] "
                new_marker = "*" if node.is_new else " "
                
                # Determine color based on changes
                key = str(node.path.relative_to(self.agents_collection))
                change = self.changes.get(key)
                
                if change == 'add':
                    color = curses.color_pair(3)  # Green
                    status = " +"
                elif change == 'remove':
                    color = curses.color_pair(1)  # Red
                    status = " -"
                else:
                    color = curses.color_pair(7)
                    status = ""
                
                line = f"{marker}{indent}  {checkbox}{new_marker}{node.name[:30]}{status}"
                stdscr.addstr(y, 0, line[:width//2], color | attr)
                
                # Description on the right
                if width > 80:
                    desc_x = min(50, width // 2)
                    desc = node.description[:width - desc_x - 2]
                    stdscr.addstr(y, desc_x, desc, curses.color_pair(6))
            
            y += 1
        
        # Scroll indicator
        if len(self.flattened_nodes) > visible_height:
            scroll_text = f"({scroll_offset + 1}-{visible_end}/{len(self.flattened_nodes)})"
            stdscr.addstr(height - 3, width - len(scroll_text) - 2, scroll_text, curses.color_pair(6))
    
    def draw_instructions(self, stdscr, height, width):
        """Draw instructions bar"""
        stdscr.addstr(height - 2, 0, "─" * width, curses.color_pair(6))
        
        if self.current_view == View.GENERAL:
            mode = "[1] Ver Proyecto  [2] Ver Usuario"
        else:
            mode = "[1] Ver Proyecto  [2] Ver Usuario"
        
        instructions = f"{mode}  [SPACE] Seleccionar/Expandir  [v] Ver  [g] Fuentes  [s] Guardar  [q] Salir"
        
        if len(instructions) < width:
            stdscr.addstr(height - 1, 2, instructions[:width-3], curses.color_pair(6))
    
    def show_confirmation(self, stdscr, height, width):
        """Show confirmation dialog"""
        adds, removes = self.get_changes_summary()
        
        if not adds and not removes:
            return False
        
        dialog_height = 10 + len(adds) + len(removes)
        dialog_width = 70
        dialog_y = (height - dialog_height) // 2
        dialog_x = (width - dialog_width) // 2
        
        dialog = curses.newwin(dialog_height, dialog_width, dialog_y, dialog_x)
        dialog.box()
        
        title = " Confirmar Cambios "
        dialog.addstr(0, (dialog_width - len(title)) // 2, title, curses.A_BOLD)
        
        y = 2
        # Show exact path
        if self.current_view == View.GENERAL:
            target_path = str(self.user_agents)
            target_label = "Usuario"
        else:
            target_path = str(self.project_agents)
            target_label = "Proyecto"
        
        # Truncate path if too long
        max_path_len = dialog_width - 15
        if len(target_path) > max_path_len:
            target_path = "..." + target_path[-(max_path_len-3):]
        
        dialog.addstr(y, 2, f"{target_label}: {target_path}", curses.A_BOLD)
        y += 2
        
        if adds:
            dialog.addstr(y, 2, f"Se añadirán ({len(adds)}):", curses.color_pair(3) | curses.A_BOLD)
            y += 1
            for agent in adds[:5]:
                dialog.addstr(y, 4, f"+ {agent}", curses.color_pair(3))
                y += 1
            if len(adds) > 5:
                dialog.addstr(y, 4, f"... y {len(adds) - 5} más", curses.color_pair(3))
                y += 1
            y += 1
        
        if removes:
            dialog.addstr(y, 2, f"Se eliminarán ({len(removes)}):", curses.color_pair(1) | curses.A_BOLD)
            y += 1
            for agent in removes[:5]:
                dialog.addstr(y, 4, f"- {agent}", curses.color_pair(1))
                y += 1
            if len(removes) > 5:
                dialog.addstr(y, 4, f"... y {len(removes) - 5} más", curses.color_pair(1))
                y += 1
        
        dialog.addstr(dialog_height - 2, 2, "¿Confirmar? [s/n]", curses.A_BOLD)
        dialog.refresh()
        
        while True:
            key = dialog.getch()
            if key in [ord('s'), ord('S'), ord('y'), ord('Y')]:
                return True
            elif key in [ord('n'), ord('N'), 27]:
                return False
    
    def run(self, stdscr):
        """Main UI loop"""
        curses.curs_set(0)
        curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(4, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(5, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(6, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(7, curses.COLOR_WHITE, curses.COLOR_BLACK)
        
        while True:
            height, width = stdscr.getmaxyx()
            stdscr.clear()
            
            self.draw_header(stdscr, height, width)
            
            if self.current_view == View.SOURCES:
                self.draw_sources_view(stdscr, height, width)
                self.draw_sources_instructions(stdscr, height, width)
            else:
                self.draw_tree(stdscr, height, width)
                self.draw_instructions(stdscr, height, width)
            
            stdscr.refresh()
            
            key = stdscr.getch()
            
            # Navigation
            if key == curses.KEY_UP:
                if self.current_view == View.SOURCES:
                    self.handle_sources_navigation(key)
                else:
                    if self.current_index > 0:
                        self.current_index -= 1
            
            elif key == curses.KEY_DOWN:
                if self.current_view == View.SOURCES:
                    self.handle_sources_navigation(key)
                else:
                    if self.current_index < len(self.flattened_nodes) - 1:
                        self.current_index += 1
            
            elif key == curses.KEY_RIGHT or key == ord('\n'):
                # Expand folder
                if self.current_index < len(self.flattened_nodes):
                    node = self.flattened_nodes[self.current_index]
                    if node.is_folder and not node.expanded:
                        node.expanded = True
                        self.flatten_tree()
            
            elif key == curses.KEY_LEFT:
                # Collapse folder or go to parent
                if self.current_index < len(self.flattened_nodes):
                    node = self.flattened_nodes[self.current_index]
                    if node.is_folder and node.expanded:
                        node.expanded = False
                        self.flatten_tree()
                    elif node.parent and node.parent.level >= 0:
                        # Jump to parent folder
                        for i, n in enumerate(self.flattened_nodes):
                            if n == node.parent:
                                self.current_index = i
                                break
            
            # Space - toggle selection or expand/collapse folder
            elif key == ord(' '):
                if self.current_view == View.SOURCES:
                    self.handle_sources_navigation(key)
                else:
                    if self.current_index < len(self.flattened_nodes):
                        node = self.flattened_nodes[self.current_index]
                        if node.is_folder:
                            # Toggle expand/collapse for folders
                            node.toggle_expand()
                            self.flatten_tree()
                        else:
                            # Toggle selection for agents
                            self.toggle_selection(node)
            
            
            # View switching
            elif key == ord('1') and self.project_root:
                if self.current_view != View.PROJECT:
                    self.current_view = View.PROJECT
                    self.current_index = 0
                    self.load_installation_state()
                    self.flatten_tree()
                    # Force update of changes summary after view switch
                    self.update_all_changes_summary()
            
            elif key == ord('2'):
                if self.current_view != View.GENERAL:
                    self.current_view = View.GENERAL
                    self.current_index = 0
                    self.load_installation_state()
                    self.flatten_tree()
                    # Force update of changes summary after view switch
                    self.update_all_changes_summary()
            
            # View file
            elif key == ord('v') or key == ord('V'):
                if self.current_index < len(self.flattened_nodes):
                    node = self.flattened_nodes[self.current_index]
                    if not node.is_folder:
                        self.view_agent_file(node)
            
            # Save
            elif key == ord('s') or key == ord('S'):
                if self.current_view == View.SOURCES:
                    self.handle_sources_save_action()
                else:
                    if self.show_confirmation(stdscr, height, width):
                        self.save_changes()
            
            # Sources management (new)
            elif key == ord('g') or key == ord('G'):
                if self.current_view != View.SOURCES:
                    self.current_view = View.SOURCES
                    self.sources_index = 0
            
            # Handle additional sources navigation when in sources view
            elif self.current_view == View.SOURCES and key in [ord('a'), ord('A'), ord('d'), ord('D'), ord('u'), ord('U')]:
                self.handle_sources_navigation(key)
            
            # Select all in current folder
            elif key == ord('a') or key == ord('A'):
                if self.current_index < len(self.flattened_nodes):
                    current = self.flattened_nodes[self.current_index]
                    parent = current.parent if not current.is_folder else current
                    
                    for node in self.flattened_nodes:
                        if not node.is_folder and node.parent == parent:
                            node.selected = True
                            key = str(node.path.relative_to(self.agents_collection))
                            self.current_state[key] = True
                            if self.current_state[key] != self.original_state[key]:
                                self.changes[key] = 'add'
                            else:
                                self.changes[key] = None
                    
                    # Update changes summary
                    self.update_all_changes_summary()
            
            # Deselect all in current folder
            elif key == ord('n') or key == ord('N'):
                if self.current_index < len(self.flattened_nodes):
                    current = self.flattened_nodes[self.current_index]
                    parent = current.parent if not current.is_folder else current
                    
                    for node in self.flattened_nodes:
                        if not node.is_folder and node.parent == parent:
                            node.selected = False
                            key = str(node.path.relative_to(self.agents_collection))
                            self.current_state[key] = False
                            if self.current_state[key] != self.original_state[key]:
                                self.changes[key] = 'remove'
                            else:
                                self.changes[key] = None
                    
                    # Update changes summary
                    self.update_all_changes_summary()
            
            # Quit
            elif key == ord('q') or key == ord('Q'):
                adds, removes = self.get_changes_summary()
                if adds or removes:
                    if not self.show_confirmation(stdscr, height, width):
                        continue
                    else:
                        self.save_changes()
                break
            
            # ESC - cancel changes or exit sources view
            elif key == 27:
                if self.current_view == View.SOURCES:
                    self.current_view = View.GENERAL
                    self.current_index = 0
                else:
                    self.load_installation_state()
                    self.flatten_tree()
    
    def draw_sources_view(self, stdscr, height, width):
        """Draw the sources management view"""
        start_y = 6
        max_visible = height - 8
        
        sources = self.sources_manager.config.sources
        
        # Draw sources list
        for i, source in enumerate(sources):
            if i >= max_visible:
                break
                
            y_pos = start_y + i
            is_current = i == self.sources_index
            
            # Source status icon
            if source.enabled:
                status = "●" if source.enabled else "○"
                status_color = curses.color_pair(3) if source.enabled else curses.color_pair(6)
            else:
                status = "○"
                status_color = curses.color_pair(6)
            
            # Priority indicator
            priority_text = f"[{source.priority:3d}]"
            
            # Source info
            sync_status = ""
            if source.last_sync:
                try:
                    last_sync = datetime.fromisoformat(source.last_sync.replace('Z', '+00:00'))
                    time_ago = datetime.now() - last_sync.replace(tzinfo=None)
                    if time_ago.days > 0:
                        sync_status = f" (synced {time_ago.days}d ago)"
                    elif time_ago.seconds > 3600:
                        sync_status = f" (synced {time_ago.seconds//3600}h ago)"
                    else:
                        sync_status = f" (synced {time_ago.seconds//60}m ago)"
                except:
                    sync_status = " (sync time unknown)"
            else:
                sync_status = " (never synced)"
            
            # Build display line
            source_line = f"{status} {priority_text} {source.name}"
            if len(source_line) > width - 20:
                source_line = source_line[:width-23] + "..."
            
            # Draw the line
            if is_current:
                stdscr.addstr(y_pos, 2, source_line, curses.color_pair(1) | curses.A_BOLD)
                # Show details on second line
                if y_pos + 1 < height - 3:
                    details = f"    {source.url}{sync_status}"
                    if len(details) > width - 4:
                        details = details[:width-7] + "..."
                    stdscr.addstr(y_pos + 1, 2, details, curses.color_pair(6))
            else:
                stdscr.addstr(y_pos, 2, status, status_color)
                stdscr.addstr(y_pos, 4, f"{priority_text} {source.name}")
        
        # Show status messages
        if self.sources_status_messages:
            msg_start_y = height - 6
            for i, msg in enumerate(self.sources_status_messages[-3:]):  # Show last 3 messages
                if msg_start_y + i < height - 3:
                    stdscr.addstr(msg_start_y + i, 2, msg[:width-4], curses.color_pair(4))
    
    def draw_sources_instructions(self, stdscr, height, width):
        """Draw sources view instructions"""
        stdscr.addstr(height - 2, 0, "─" * width, curses.color_pair(6))
        
        instructions = "[↑/↓] Nav  [SPACE] Toggle  [a] Add  [d] Delete  [u] Update  [ESC] Back  [q] Quit"
        
        if len(instructions) < width:
            stdscr.addstr(height - 1, 2, instructions[:width-3], curses.color_pair(6))
    
    def handle_sources_navigation(self, key):
        """Handle navigation in sources view"""
        sources_count = len(self.sources_manager.config.sources)
        
        if key == curses.KEY_UP:
            self.sources_index = max(0, self.sources_index - 1)
        elif key == curses.KEY_DOWN:
            self.sources_index = min(sources_count - 1, self.sources_index + 1)
        elif key == ord(' '):
            # Toggle source enabled/disabled
            if self.sources_index < sources_count:
                source = self.sources_manager.config.sources[self.sources_index]
                new_state = self.sources_manager.toggle_source(source.id)
                if new_state is not None:
                    status = "enabled" if new_state else "disabled"
                    self.sources_status_messages.append(f"Source '{source.name}' {status}")
        elif key == ord('a') or key == ord('A'):
            # Add new source (placeholder)
            self.sources_status_messages.append("Add source: Feature coming soon")
        elif key == ord('d') or key == ord('D'):
            # Delete source
            if self.sources_index < sources_count:
                source = self.sources_manager.config.sources[self.sources_index]
                if source.id != "default":  # Protect default source
                    if self.sources_manager.remove_source(source.id):
                        self.sources_status_messages.append(f"Removed source '{source.name}'")
                        self.sources_index = min(self.sources_index, len(self.sources_manager.config.sources) - 1)
                else:
                    self.sources_status_messages.append("Cannot delete default source")
        elif key == ord('u') or key == ord('U'):
            # Update/sync sources
            if not self.sync_in_progress:
                self.sync_sources_async()
        
        # Keep status messages manageable
        if len(self.sources_status_messages) > 10:
            self.sources_status_messages = self.sources_status_messages[-10:]
    
    def sync_sources_async(self):
        """Sync sources in background"""
        if self.sync_in_progress:
            return
        
        def progress_callback(message):
            self.sources_status_messages.append(message)
        
        def sync_thread():
            self.sync_in_progress = True
            self.sources_status_messages.append("Starting sync...")
            results = self.sources_manager.sync_all_sources(progress_callback)
            
            success_count = sum(1 for success in results.values() if success)
            total_count = len(results)
            
            self.sources_status_messages.append(f"Sync complete: {success_count}/{total_count} successful")
            
            # Reload agents collection if sync was successful
            if success_count > 0:
                try:
                    new_collection = self.sources_manager.get_merged_agents_collection()
                    if new_collection.exists():
                        self.agents_collection = new_collection
                        self.build_tree()
                        self.load_installation_state()
                        self.flatten_tree()
                        self.sources_status_messages.append("Agents collection refreshed")
                except Exception as e:
                    self.sources_status_messages.append(f"Error refreshing collection: {e}")
            
            self.sync_in_progress = False
        
        thread = threading.Thread(target=sync_thread, daemon=True)
        thread.start()
    
    def handle_sources_save_action(self):
        """Handle save action in sources view (sync all)"""
        if not self.sync_in_progress:
            self.sync_sources_async()
    
    def check_auto_sync_on_startup(self):
        """Check if auto-sync is needed on startup"""
        if not self.sources_manager.config.auto_sync:
            return
        
        now = datetime.now()
        last_sync = self.sources_manager.config.last_auto_sync
        
        should_sync = False
        
        if last_sync is None:
            # Never synced before
            should_sync = True
        else:
            try:
                last_sync_time = datetime.fromisoformat(last_sync.replace('Z', '+00:00')).replace(tzinfo=None)
                time_since_sync = now - last_sync_time
                
                if time_since_sync.total_seconds() > self.sources_manager.config.sync_interval:
                    should_sync = True
            except (ValueError, TypeError):
                # Invalid date format, sync to be safe
                should_sync = True
        
        if should_sync:
            self.sync_sources_startup_async()
    
    def sync_sources_startup_async(self):
        """Sync sources on startup in background"""
        def startup_sync_thread():
            self.sync_in_progress = True
            
            # Only sync if sources have content that needs updating
            enabled_sources = self.sources_manager.get_enabled_sources()
            if not enabled_sources:
                self.sync_in_progress = False
                return
            
            # Check if we have cached data first - if not, definitely sync
            needs_sync = False
            for source in enabled_sources:
                cache_path = self.sources_manager.get_source_cache_path(source.id)
                if not cache_path.exists():
                    needs_sync = True
                    break
            
            if needs_sync or True:  # Always sync on startup for now
                results = self.sources_manager.sync_all_sources()
                success_count = sum(1 for success in results.values() if success)
                
                if success_count > 0:
                    # Update last sync time
                    self.sources_manager.config.last_auto_sync = datetime.now().isoformat()
                    self.sources_manager.save_config()
                    
                    # Refresh collection if sync was successful
                    try:
                        new_collection = self.sources_manager.get_merged_agents_collection()
                        if new_collection.exists():
                            self.agents_collection = new_collection
                            # Note: We don't rebuild tree here to avoid UI disruption
                            # Tree will use new collection on next restart or manual refresh
                    except:
                        pass  # Silently fail to avoid startup disruption
            
            self.sync_in_progress = False
        
        # Run sync in background thread to not block UI startup
        thread = threading.Thread(target=startup_sync_thread, daemon=True)
        thread.start()

def main():
    try:
        manager = AgentManagerTree()
        curses.wrapper(manager.run)
        print("\n¡Hasta luego!")
    except KeyboardInterrupt:
        print("\n¡Hasta luego!")
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()