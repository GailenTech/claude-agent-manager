#!/usr/bin/env python3

import curses
import os
from pathlib import Path
import shutil
from enum import Enum
from datetime import datetime, timedelta
import tempfile
import sys
import json
import subprocess
import threading
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from urllib.parse import urlparse

class View(Enum):
    GENERAL = "general"    # User level (~/.claude/agents)
    PROJECT = "project"    # Project level (.claude/agents)
    SOURCES = "sources"    # Sources management

@dataclass
class AgentSource:
    """Represents an agent source configuration"""
    id: str
    name: str
    url: str
    path: str = "agents-collection"
    enabled: bool = True
    priority: int = 50
    last_sync: Optional[str] = None
    branch: str = "main"
    readonly: bool = True
    source_type: str = "git"  # git, local, http
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AgentSource':
        return cls(**data)

@dataclass 
class SourcesConfig:
    """Configuration for the sources system"""
    version: str = "1.0"
    sources: List[AgentSource] = None
    auto_sync: bool = True
    sync_interval: int = 86400  # 24 hours
    last_auto_sync: Optional[str] = None
    
    def __post_init__(self):
        if self.sources is None:
            # Default source - our repository
            self.sources = [
                AgentSource(
                    id="default",
                    name="Claude Agent Manager Official",
                    url="https://github.com/GailenTech/claude-agent-manager.git",
                    path="agents-collection",
                    enabled=True,
                    priority=100,
                    readonly=False
                )
            ]
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "version": self.version,
            "sources": [source.to_dict() for source in self.sources],
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
            "last_auto_sync": self.last_auto_sync
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SourcesConfig':
        sources = [AgentSource.from_dict(s) for s in data.get('sources', [])]
        return cls(
            version=data.get('version', '1.0'),
            sources=sources,
            auto_sync=data.get('auto_sync', True),
            sync_interval=data.get('sync_interval', 86400),
            last_auto_sync=data.get('last_auto_sync')
        )

class SourcesManager:
    """Manages agent sources - loading, syncing, caching"""
    
    def __init__(self):
        self.config_dir = Path.home() / ".config" / "claude-agent-manager"
        self.cache_dir = Path.home() / ".cache" / "claude-agent-manager" / "sources"
        self.config_file = self.config_dir / "sources.json"
        
        # Ensure directories exist
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        self.config: Optional[SourcesConfig] = None
        self.load_config()
    
    def load_config(self) -> SourcesConfig:
        """Load sources configuration from file"""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    data = json.load(f)
                self.config = SourcesConfig.from_dict(data)
            except (json.JSONDecodeError, KeyError) as e:
                print(f"Error loading sources config: {e}")
                self.config = SourcesConfig()
                self.save_config()
        else:
            self.config = SourcesConfig()
            self.save_config()
        
        return self.config
    
    def save_config(self):
        """Save sources configuration to file"""
        with open(self.config_file, 'w') as f:
            json.dump(self.config.to_dict(), f, indent=2)
    
    def get_enabled_sources(self) -> List[AgentSource]:
        """Get list of enabled sources sorted by priority (descending)"""
        enabled = [s for s in self.config.sources if s.enabled]
        return sorted(enabled, key=lambda x: x.priority, reverse=True)
    
    def add_source(self, source: AgentSource) -> bool:
        """Add a new source"""
        # Check if ID already exists
        if any(s.id == source.id for s in self.config.sources):
            return False
        
        self.config.sources.append(source)
        self.save_config()
        return True
    
    def remove_source(self, source_id: str) -> bool:
        """Remove a source by ID"""
        original_count = len(self.config.sources)
        self.config.sources = [s for s in self.config.sources if s.id != source_id]
        
        if len(self.config.sources) < original_count:
            # Also remove cached data
            cache_path = self.cache_dir / source_id
            if cache_path.exists():
                shutil.rmtree(cache_path)
            
            self.save_config()
            return True
        return False
    
    def toggle_source(self, source_id: str) -> Optional[bool]:
        """Toggle source enabled/disabled state. Returns new state or None if not found"""
        for source in self.config.sources:
            if source.id == source_id:
                source.enabled = not source.enabled
                self.save_config()
                return source.enabled
        return None
    
    def get_source_cache_path(self, source_id: str) -> Path:
        """Get cache path for a source"""
        return self.cache_dir / source_id
    
    def sync_source(self, source_id: str, progress_callback=None) -> bool:
        """Sync a single source"""
        source = next((s for s in self.config.sources if s.id == source_id), None)
        if not source:
            return False
        
        cache_path = self.get_source_cache_path(source_id)
        
        try:
            if source.source_type == "git":
                return self._sync_git_source(source, cache_path, progress_callback)
            elif source.source_type == "local":
                return self._sync_local_source(source, cache_path, progress_callback)
            # TODO: Add HTTP source support
            
        except Exception as e:
            if progress_callback:
                progress_callback(f"Error syncing {source.name}: {e}")
            return False
        
        return False
    
    def _sync_git_source(self, source: AgentSource, cache_path: Path, progress_callback=None) -> bool:
        """Sync a git-based source"""
        if progress_callback:
            progress_callback(f"Syncing {source.name}...")
        
        try:
            if cache_path.exists():
                # Update existing repo
                result = subprocess.run([
                    'git', '-C', str(cache_path), 'pull', 'origin', source.branch
                ], capture_output=True, text=True, timeout=60)
                
                if result.returncode != 0:
                    if progress_callback:
                        progress_callback(f"Git pull failed: {result.stderr}")
                    return False
            else:
                # Clone new repo
                cache_path.parent.mkdir(parents=True, exist_ok=True)
                result = subprocess.run([
                    'git', 'clone', '--depth', '1', '--branch', source.branch, 
                    source.url, str(cache_path)
                ], capture_output=True, text=True, timeout=120)
                
                if result.returncode != 0:
                    if progress_callback:
                        progress_callback(f"Git clone failed: {result.stderr}")
                    return False
            
            # Update last sync time
            source.last_sync = datetime.now().isoformat()
            self.save_config()
            
            if progress_callback:
                progress_callback(f"âœ“ {source.name} synced successfully")
            
            return True
            
        except subprocess.TimeoutExpired:
            if progress_callback:
                progress_callback(f"Timeout syncing {source.name}")
            return False
        except Exception as e:
            if progress_callback:
                progress_callback(f"Error syncing {source.name}: {e}")
            return False
    
    def _sync_local_source(self, source: AgentSource, cache_path: Path, progress_callback=None) -> bool:
        """Sync a local directory source"""
        if progress_callback:
            progress_callback(f"Syncing local source {source.name}...")
        
        local_path = Path(source.url)
        if not local_path.exists():
            if progress_callback:
                progress_callback(f"Local path not found: {local_path}")
            return False
        
        try:
            # Determine the actual source path
            # If source.path is provided and not empty/default, append it
            if source.path and source.path not in ['', '.', 'agents-collection']:
                source_path = local_path / source.path
            else:
                source_path = local_path
            
            # Check if the source path exists
            if not source_path.exists():
                if progress_callback:
                    progress_callback(f"Source path not found: {source_path}")
                return False
            
            # Copy local directory to cache
            if cache_path.exists():
                shutil.rmtree(cache_path)
            
            # Create cache directory and copy contents
            cache_path.mkdir(parents=True, exist_ok=True)
            
            # Copy all .md files from source to cache
            md_files_copied = 0
            for md_file in source_path.rglob("*.md"):
                rel_path = md_file.relative_to(source_path)
                dest_file = cache_path / rel_path
                dest_file.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(md_file, dest_file)
                md_files_copied += 1
            
            if progress_callback:
                progress_callback(f"Copied {md_files_copied} agent files from {source.name}")
            
            source.last_sync = datetime.now().isoformat()
            self.save_config()
            
            if progress_callback:
                progress_callback(f"âœ“ {source.name} synced successfully")
            
            return True
            
        except Exception as e:
            if progress_callback:
                progress_callback(f"Error syncing {source.name}: {e}")
            return False
    
    def get_merged_agents_collection(self) -> Path:
        """Get a merged view of all enabled sources"""
        merged_path = self.cache_dir / "_merged"
        
        # Check if merge is up to date
        if self._is_merge_current(merged_path):
            return merged_path
        
        # Create fresh merged collection
        return self._create_merged_collection(merged_path)
    
    def _is_merge_current(self, merged_path: Path) -> bool:
        """Check if merged collection is current"""
        if not merged_path.exists():
            return False
        
        merge_time = merged_path.stat().st_mtime
        
        # Check if any source is newer than the merge
        for source in self.get_enabled_sources():
            cache_path = self.get_source_cache_path(source.id)
            if cache_path.exists():
                if cache_path.stat().st_mtime > merge_time:
                    return False
        
        return True
    
    def _create_merged_collection(self, merged_path: Path) -> Path:
        """Create merged collection from all enabled sources"""
        if merged_path.exists():
            shutil.rmtree(merged_path)
        
        merged_path.mkdir(parents=True, exist_ok=True)
        
        # Track agents across sources for conflict resolution
        agent_registry = {}  # agent_name -> [(source_info, file_path), ...]
        
        # Process all enabled sources by priority (highest first)
        sources = self.get_enabled_sources()
        
        for source in sources:
            cache_path = self.get_source_cache_path(source.id)
            
            # Handle path correctly - if it's '.' or empty, use cache_path directly
            if source.path in ['.', '', None]:
                source_agents_path = cache_path
            else:
                source_agents_path = cache_path / source.path
            
            if not source_agents_path.exists():
                continue
            
            # Traverse source directory structure
            self._process_source_directory(
                source_agents_path, 
                source, 
                agent_registry, 
                merged_path,
                base_path=source_agents_path
            )
        
        # Create merged directory structure and resolve conflicts
        self._build_merged_structure(agent_registry, merged_path)
        
        return merged_path
    
    def _process_source_directory(self, source_dir: Path, source: AgentSource, 
                                  agent_registry: dict, merged_path: Path, 
                                  base_path: Path):
        """Process a source directory recursively"""
        if not source_dir.exists():
            return
        
        for item in source_dir.rglob("*.md"):
            # Calculate relative path from base
            try:
                rel_path = item.relative_to(base_path)
                category = str(rel_path.parent) if rel_path.parent != Path('.') else 'root'
                agent_name = item.stem
                
                # Create unique key for conflict resolution
                full_key = f"{category}/{agent_name}"
                
                if full_key not in agent_registry:
                    agent_registry[full_key] = []
                
                agent_registry[full_key].append({
                    'source': source,
                    'file_path': item,
                    'category': category,
                    'agent_name': agent_name,
                    'rel_path': rel_path
                })
                
            except ValueError:
                # Skip files outside base path
                continue
    
    def _build_merged_structure(self, agent_registry: dict, merged_path: Path):
        """Build the final merged directory structure"""
        for full_key, agent_variants in agent_registry.items():
            if len(agent_variants) == 1:
                # No conflict - direct copy using original relative path
                variant = agent_variants[0]
                rel_path = variant['rel_path']
                dest_file = merged_path / rel_path
                
                # Create parent directories
                dest_file.parent.mkdir(parents=True, exist_ok=True)
                
                shutil.copy2(variant['file_path'], dest_file)
                
                # Add source attribution
                self._add_source_attribution(dest_file, variant['source'])
            else:
                # Conflict resolution - create variants with source suffix
                for i, variant in enumerate(sorted(agent_variants, key=lambda x: x['source'].priority, reverse=True)):
                    rel_path = variant['rel_path']
                    
                    if i == 0:
                        # Highest priority gets original path
                        dest_file = merged_path / rel_path
                    else:
                        # Lower priority gets source suffix in filename
                        source_suffix = self._get_source_suffix(variant['source'])
                        # Insert suffix before .md extension
                        stem = rel_path.stem
                        parent = rel_path.parent
                        dest_file = merged_path / parent / f"{stem}-{source_suffix}.md"
                    
                    # Create parent directories
                    dest_file.parent.mkdir(parents=True, exist_ok=True)
                    
                    shutil.copy2(variant['file_path'], dest_file)
                    self._add_source_attribution(dest_file, variant['source'])
        
        # Create a metadata file for the merge
        self._create_merge_metadata(merged_path, agent_registry)
    
    def _get_source_suffix(self, source: AgentSource) -> str:
        """Get a short suffix for source identification"""
        # Use source ID, but make it shorter and cleaner
        suffix = source.id.replace('-', '')[:8]
        return suffix
    
    def _add_source_attribution(self, file_path: Path, source: AgentSource):
        """Add source attribution to agent file"""
        try:
            content = file_path.read_text()
            
            # Add source info after YAML frontmatter if not already present
            if '<!-- Source:' not in content:
                lines = content.split('\n')
                
                # Find end of YAML frontmatter
                yaml_end = -1
                if lines and lines[0] == '---':
                    for i, line in enumerate(lines[1:], 1):
                        if line == '---':
                            yaml_end = i
                            break
                
                # Insert source attribution after YAML
                if yaml_end > 0:
                    attribution = f"\n<!-- Source: {source.name} ({source.url}) -->\n"
                    lines.insert(yaml_end + 1, attribution)
                    file_path.write_text('\n'.join(lines))
                    
        except Exception:
            # If we can't add attribution, continue anyway
            pass
    
    def _create_merge_metadata(self, merged_path: Path, agent_registry: dict):
        """Create metadata file about the merge"""
        metadata = {
            'merge_time': datetime.now().isoformat(),
            'sources_used': [],
            'conflicts_resolved': 0,
            'total_agents': len(agent_registry)
        }
        
        # Count sources and conflicts
        sources_seen = set()
        conflicts = 0
        
        for agents_variants in agent_registry.values():
            if len(agents_variants) > 1:
                conflicts += 1
            for variant in agents_variants:
                sources_seen.add(variant['source'].id)
        
        metadata['conflicts_resolved'] = conflicts
        metadata['sources_used'] = list(sources_seen)
        
        # Write metadata
        metadata_file = merged_path / '.merge_info.json'
        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2)
    
    def sync_all_sources(self, progress_callback=None) -> Dict[str, bool]:
        """Sync all enabled sources"""
        results = {}
        for source in self.get_enabled_sources():
            results[source.id] = self.sync_source(source.id, progress_callback)
        return results

class TreeNode:
    def __init__(self, name, path, is_folder=False, level=0):
        self.name = name
        self.path = path
        self.is_folder = is_folder
        self.level = level
        self.expanded = level < 2  # Auto-expand first 2 levels
        self.children = []
        self.parent = None
        self.selected = False
        self.installed = False
        self.description = ""
        self.is_new = False
        self.agent_count = 0  # For folders
        self.changes_summary = {'add': 0, 'remove': 0}  # Track changes in folder
        
    def get_display_name(self):
        """Get display name with folder indicators"""
        if self.is_folder:
            if self.expanded:
                prefix = "â–¼ "
            else:
                prefix = "â–¶ "
            
            if self.agent_count > 0:
                return f"{prefix}{self.name.upper() if self.level == 0 else self.name}"
            else:
                return f"{prefix}{self.name.upper() if self.level == 0 else self.name}"
        else:
            return self.name
    
    def get_agent_count_recursive(self):
        """Count all agents in this folder and subfolders"""
        if not self.is_folder:
            return 1
        
        count = 0
        for child in self.children:
            if child.is_folder:
                count += child.get_agent_count_recursive()
            else:
                count += 1
        return count
    
    def toggle_expand(self):
        """Toggle folder expansion"""
        if self.is_folder:
            self.expanded = not self.expanded
    
    def update_changes_summary(self, changes_dict, agent_manager=None):
        """Update changes summary for this node and propagate to parents"""
        if not self.is_folder:
            return
        
        # Reset counters
        self.changes_summary = {'add': 0, 'remove': 0}
        
        # Count changes in direct children and subfolders
        for child in self.children:
            if child.is_folder:
                # Recursively update child folders first
                child.update_changes_summary(changes_dict, agent_manager)
                # Add child folder's changes to this folder
                self.changes_summary['add'] += child.changes_summary['add']
                self.changes_summary['remove'] += child.changes_summary['remove']
            else:
                # Check if this agent has changes
                if agent_manager:
                    relative_path = agent_manager.get_relative_key(child.path)
                else:
                    # Fallback if no agent_manager provided
                    relative_path = child.path.name
                for key, change_type in changes_dict.items():
                    if change_type and child.name in key:
                        if change_type == 'add':
                            self.changes_summary['add'] += 1
                        elif change_type == 'remove':
                            self.changes_summary['remove'] += 1
    
    def get_changes_display(self):
        """Get formatted string for changes display"""
        if not self.is_folder or (self.changes_summary['add'] == 0 and self.changes_summary['remove'] == 0):
            return ""
        
        parts = []
        if self.changes_summary['add'] > 0:
            parts.append(f"+{self.changes_summary['add']}")
        if self.changes_summary['remove'] > 0:
            parts.append(f"-{self.changes_summary['remove']}")
        
        return f" [{' '.join(parts)}]" if parts else ""

class AgentManagerTree:
    def __init__(self):
        self.script_dir = Path(__file__).parent.absolute()
        
        # Initialize sources manager
        self.sources_manager = SourcesManager()
        
        # Get agents collection from sources or fallback to embedded
        collection_path = os.environ.get('CLAUDE_AGENT_COLLECTION')
        if collection_path:
            self.agents_collection = Path(collection_path)
        else:
            # Try to use merged sources collection, fallback to embedded
            try:
                self.agents_collection = self.sources_manager.get_merged_agents_collection()
                if not self.agents_collection.exists():
                    self.agents_collection = self.script_dir / "agents-collection"
            except:
                self.agents_collection = self.script_dir / "agents-collection"
        
        self.user_agents = Path.home() / ".claude" / "agents"
        self.project_root = self.detect_project()
        self.project_agents = self.project_root / ".claude" / "agents" if self.project_root else None
        
        self.current_view = View.GENERAL
        self.current_index = 0
        self.tree_root = TreeNode("root", self.agents_collection, is_folder=True, level=-1)
        self.flattened_nodes = []
        self.original_state = {}
        self.current_state = {}
        self.changes = {}
        
        # Sources view state
        self.sources_index = 0
        self.sources_status_messages = []
        self.sync_in_progress = False
        
        # Add source form state
        self.add_form_fields = {}
        self.add_form_current_field = 0
        
        # Check for auto-sync on startup
        self.check_auto_sync_on_startup()
        
        self.build_tree()
        self.load_installation_state()
        self.flatten_tree()
    
    def detect_project(self):
        """Detect git project root"""
        current = Path.cwd()
        while current != current.parent:
            if (current / ".git").exists():
                return current
            current = current.parent
        return None
    
    def is_new_agent(self, file_path):
        """Check if agent file was created in last 48 hours"""
        try:
            mtime = file_path.stat().st_mtime
            age = datetime.now() - datetime.fromtimestamp(mtime)
            return age < timedelta(hours=48)
        except:
            return False
    
    def get_relative_key(self, node_path):
        """Get relative key for a node path, handling different installations"""
        try:
            return str(node_path.relative_to(self.agents_collection))
        except ValueError:
            # Path might be from a different installation
            # Try to reconstruct the relative path from the node structure
            if node_path.is_file():
                # For files, use just the filename
                return node_path.name
            else:
                # For directories, try to use the last parts of the path
                parts = node_path.parts
                # Find common structure (e.g., backend/, frontend/, etc.)
                for i, part in enumerate(parts):
                    if part in ['backend', 'frontend', 'platform', 'infrastructure']:
                        return '/'.join(parts[i:])
                # Fallback to just the name
                return node_path.name
    
    def get_agent_info(self, file_path):
        """Extract agent description from file"""
        desc = "No description"
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    if line.startswith('description:'):
                        desc = line.replace('description:', '').strip()[:60]
                        break
        except:
            pass
        return desc
    
    def build_tree(self):
        """Build tree structure from agents collection"""
        self.tree_root.children = []
        self._build_tree_recursive(self.agents_collection, self.tree_root, 0)
        
        # Update agent counts
        for child in self.tree_root.children:
            child.agent_count = child.get_agent_count_recursive()
    
    def _build_tree_recursive(self, path, parent_node, level):
        """Recursively build tree from filesystem"""
        try:
            items = sorted(path.iterdir())
            
            # First add subdirectories
            for item in items:
                if item.is_dir() and not item.name.startswith('.'):
                    folder_node = TreeNode(item.name, item, is_folder=True, level=level)
                    folder_node.parent = parent_node
                    parent_node.children.append(folder_node)
                    
                    # Recurse into subdirectory
                    self._build_tree_recursive(item, folder_node, level + 1)
            
            # Then add .md files
            for item in items:
                if item.is_file() and item.suffix == '.md':
                    agent_node = TreeNode(item.stem, item, is_folder=False, level=level)
                    agent_node.parent = parent_node
                    agent_node.description = self.get_agent_info(item)
                    agent_node.is_new = self.is_new_agent(item)
                    parent_node.children.append(agent_node)
                    
        except PermissionError:
            pass
    
    def load_installation_state(self):
        """Load which agents are installed"""
        check_dir = self.user_agents if self.current_view == View.GENERAL else self.project_agents
        
        self.original_state = {}
        self.current_state = {}
        self.changes = {}
        
        if check_dir and check_dir.exists():
            installed_files = set(f.stem for f in check_dir.glob("*.md"))
        else:
            installed_files = set()
        
        # Mark installed agents in tree
        self._mark_installed_recursive(self.tree_root, installed_files)
        
        # Reset all change summaries when switching views
        self._reset_all_changes_summary(self.tree_root)
    
    def _mark_installed_recursive(self, node, installed_files):
        """Recursively mark installed agents"""
        if not node.is_folder:
            node.installed = node.name in installed_files
            node.selected = node.installed
            
            # Track state
            key = self.get_relative_key(node.path)
            self.original_state[key] = node.installed
            self.current_state[key] = node.installed
            self.changes[key] = None
        else:
            for child in node.children:
                self._mark_installed_recursive(child, installed_files)
    
    def _reset_all_changes_summary(self, node):
        """Reset change summaries for all folders"""
        if node.is_folder:
            node.changes_summary = {'add': 0, 'remove': 0}
            for child in node.children:
                self._reset_all_changes_summary(child)
    
    def flatten_tree(self):
        """Flatten tree to list for display, respecting expansion state"""
        self.flattened_nodes = []
        self._flatten_recursive(self.tree_root)
    
    def _flatten_recursive(self, node):
        """Recursively flatten tree"""
        # Don't include root node itself
        if node.level >= 0:
            self.flattened_nodes.append(node)
        
        # Only include children if folder is expanded or if it's root
        if node.is_folder and (node.expanded or node.level == -1):
            for child in node.children:
                self._flatten_recursive(child)
    
    def toggle_selection(self, node):
        """Toggle agent selection and track changes"""
        if node.is_folder:
            return
        
        node.selected = not node.selected
        
        key = self.get_relative_key(node.path)
        self.current_state[key] = node.selected
        
        if self.current_state[key] == self.original_state[key]:
            self.changes[key] = None
        elif self.current_state[key]:
            self.changes[key] = 'add'
        else:
            self.changes[key] = 'remove'
        
        # Update changes summary for all folders
        self.update_all_changes_summary()
    
    def update_all_changes_summary(self):
        """Update changes summary for entire tree"""
        for child in self.tree_root.children:
            child.update_changes_summary(self.changes, self)
    
    def get_changes_summary(self):
        """Get summary of pending changes"""
        adds = [Path(k).name for k, v in self.changes.items() if v == 'add']
        removes = [Path(k).name for k, v in self.changes.items() if v == 'remove']
        return adds, removes
    
    def save_changes(self):
        """Apply all changes to filesystem"""
        target_dir = self.user_agents if self.current_view == View.GENERAL else self.project_agents
        target_dir.mkdir(parents=True, exist_ok=True)
        
        for path_key, change in self.changes.items():
            if change is None:
                continue
            
            source_file = self.agents_collection / path_key
            agent_name = Path(path_key).stem
            target_file = target_dir / f"{agent_name}.md"
            
            if change == 'add' and source_file.exists():
                shutil.copy2(source_file, target_file)
            elif change == 'remove' and target_file.exists():
                target_file.unlink()
        
        # Reload state
        self.load_installation_state()
        self.flatten_tree()
    
    def view_agent_file(self, node):
        """View agent file in read-only mode"""
        if node.is_folder or not node.path.exists():
            return
        
        editor = os.environ.get('PAGER', 'less')
        if not shutil.which(editor):
            editor = 'cat'
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as tmp:
            tmp.write(f"# VIEWING (READ-ONLY): {node.name}\n")
            tmp.write(f"# Path: {self.get_relative_key(node.path)}\n")
            tmp.write(f"# {'=' * 60}\n\n")
            with open(node.path, 'r') as original:
                tmp.write(original.read())
            tmp_path = tmp.name
        
        curses.endwin()
        os.system(f"{editor} {tmp_path}")
        os.unlink(tmp_path)
        curses.doupdate()
    
    def draw_header(self, stdscr, height, width):
        """Draw header with view indicator and path"""
        # Clear the entire header area first
        for i in range(5):  # Clear first 5 lines completely
            stdscr.addstr(i, 0, "" * (width - 1))
        
        # Choose color based on view
        if self.current_view == View.GENERAL:
            header_color = curses.color_pair(2)  # Blue for General
            view_text = "General View (User)"
            target_path = str(self.user_agents)
        elif self.current_view == View.PROJECT:
            header_color = curses.color_pair(3)  # Green for Project
            view_text = f"Project View: {self.project_root.name}"
            target_path = str(self.project_agents)
        else:  # View.SOURCES
            header_color = curses.color_pair(5)  # Cyan for Sources
            view_text = "Sources Management"
            enabled_count = len(self.sources_manager.get_enabled_sources())
            total_count = len(self.sources_manager.config.sources)
            target_path = f"{enabled_count}/{total_count} active sources"
        
        # Truncate path if needed
        max_path_len = width - 10
        if len(target_path) > max_path_len:
            display_path = "..." + target_path[-(max_path_len-3):]
        else:
            display_path = target_path
        
        stdscr.addstr(0, 0, "â•”" + "â•" * (width-2) + "â•—", header_color | curses.A_BOLD)
        stdscr.addstr(1, 0, "â•‘", header_color | curses.A_BOLD)
        stdscr.addstr(1, width-1, "â•‘", header_color | curses.A_BOLD)
        
        title = f"Agent Manager - {view_text}"
        title_x = (width - len(title)) // 2
        stdscr.addstr(1, title_x, title, header_color | curses.A_BOLD)
        
        stdscr.addstr(2, 0, "â•‘", header_color | curses.A_BOLD)
        stdscr.addstr(2, width-1, "â•‘", header_color | curses.A_BOLD)
        
        # Show path on second line
        path_x = (width - len(display_path)) // 2
        stdscr.addstr(2, path_x, display_path, header_color)
        
        stdscr.addstr(3, 0, "â•š" + "â•" * (width-2) + "â•", header_color | curses.A_BOLD)
        
        
        adds, removes = self.get_changes_summary()
        if adds or removes:
            changes_text = "Cambios: "
            if adds:
                changes_text += f"+{len(adds)} "
            if removes:
                changes_text += f"-{len(removes)}"
            stdscr.addstr(4, 2, changes_text, curses.color_pair(4) | curses.A_BOLD)
        
        # Show sync status if in progress
        if self.sync_in_progress:
            sync_text = "ðŸ”„ Syncing sources..."
            stdscr.addstr(4, width - len(sync_text) - 2, sync_text, curses.color_pair(4))
    
    def draw_tree(self, stdscr, height, width):
        """Draw tree with proper indentation"""
        start_y = 6
        visible_height = height - 8
        
        # Calculate visible range
        if self.current_index >= visible_height:
            scroll_offset = self.current_index - visible_height + 1
        else:
            scroll_offset = 0
        
        visible_end = min(len(self.flattened_nodes), scroll_offset + visible_height)
        
        y = start_y
        for i in range(scroll_offset, visible_end):
            node = self.flattened_nodes[i]
            
            # Indentation
            indent = "  " * node.level
            
            # Selection marker
            if i == self.current_index:
                marker = "â–¶ "
                attr = curses.A_REVERSE
            else:
                marker = "  "
                attr = 0
            
            # Build display string
            if node.is_folder:
                # Folder display
                display_name = node.get_display_name()
                if node.agent_count > 0:
                    count_text = f" ({node.agent_count} agents)"
                else:
                    count_text = " (empty)"
                
                # Add changes summary if any
                changes_text = node.get_changes_display()
                
                line = f"{marker}{indent}{display_name}{count_text}{changes_text}"
                
                # Use different color for top-level folders
                if node.level == 0:
                    color = curses.color_pair(5) | curses.A_BOLD
                else:
                    color = curses.color_pair(6)
                
                # Apply change colors to the changes part
                if changes_text:
                    base_line = f"{marker}{indent}{display_name}{count_text}"
                    stdscr.addstr(y, 0, base_line[:width-len(changes_text)-1], color | attr)
                    
                    # Color the changes part
                    if node.changes_summary['add'] > 0 and node.changes_summary['remove'] > 0:
                        change_color = curses.color_pair(4)  # Yellow for mixed
                    elif node.changes_summary['add'] > 0:
                        change_color = curses.color_pair(3)  # Green for adds
                    else:
                        change_color = curses.color_pair(1)  # Red for removes
                    
                    stdscr.addstr(y, len(base_line), changes_text, change_color | attr)
                else:
                    stdscr.addstr(y, 0, line[:width-1], color | attr)
                
            else:
                # Agent display
                checkbox = "[âœ“] " if node.selected else "[ ] "
                new_marker = "*" if node.is_new else " "
                
                # Determine color based on changes
                try:
                    key = self.get_relative_key(node.path)
                except ValueError:
                    # Path might be from a different installation, use filename
                    key = node.path.name
                change = self.changes.get(key)
                
                if change == 'add':
                    color = curses.color_pair(3)  # Green
                    status = " +"
                elif change == 'remove':
                    color = curses.color_pair(1)  # Red
                    status = " -"
                else:
                    color = curses.color_pair(7)
                    status = ""
                
                line = f"{marker}{indent}  {checkbox}{new_marker}{node.name[:30]}{status}"
                stdscr.addstr(y, 0, line[:width//2], color | attr)
                
                # Description on the right
                if width > 80:
                    desc_x = min(50, width // 2)
                    desc = node.description[:width - desc_x - 2]
                    stdscr.addstr(y, desc_x, desc, curses.color_pair(6))
            
            y += 1
        
        # Scroll indicator
        if len(self.flattened_nodes) > visible_height:
            scroll_text = f"({scroll_offset + 1}-{visible_end}/{len(self.flattened_nodes)})"
            stdscr.addstr(height - 3, width - len(scroll_text) - 2, scroll_text, curses.color_pair(6))
    
    def draw_instructions(self, stdscr, height, width):
        """Draw instructions bar"""
        stdscr.addstr(height - 2, 0, "â”€" * width, curses.color_pair(6))
        
        if self.current_view == View.GENERAL:
            mode = "[1] Project View  [2] User View"
        else:
            mode = "[1] Project View  [2] User View"
        
        instructions = f"{mode}  [SPACE] Select/Expand  [v] View  [g] Sources  [s] Save  [q] Quit"
        
        if len(instructions) < width:
            stdscr.addstr(height - 1, 2, instructions[:width-3], curses.color_pair(6))
    
    def show_confirmation(self, stdscr, height, width):
        """Show confirmation dialog"""
        adds, removes = self.get_changes_summary()
        
        if not adds and not removes:
            return False
        
        dialog_height = 10 + len(adds) + len(removes)
        dialog_width = 70
        dialog_y = (height - dialog_height) // 2
        dialog_x = (width - dialog_width) // 2
        
        dialog = curses.newwin(dialog_height, dialog_width, dialog_y, dialog_x)
        dialog.box()
        
        title = " Confirm Changes "
        dialog.addstr(0, (dialog_width - len(title)) // 2, title, curses.A_BOLD)
        
        y = 2
        # Show exact path
        if self.current_view == View.GENERAL:
            target_path = str(self.user_agents)
            target_label = "User"
        else:
            target_path = str(self.project_agents)
            target_label = "Project"
        
        # Truncate path if too long
        max_path_len = dialog_width - 15
        if len(target_path) > max_path_len:
            target_path = "..." + target_path[-(max_path_len-3):]
        
        dialog.addstr(y, 2, f"{target_label}: {target_path}", curses.A_BOLD)
        y += 2
        
        if adds:
            dialog.addstr(y, 2, f"Will add ({len(adds)}):", curses.color_pair(3) | curses.A_BOLD)
            y += 1
            for agent in adds[:5]:
                dialog.addstr(y, 4, f"+ {agent}", curses.color_pair(3))
                y += 1
            if len(adds) > 5:
                dialog.addstr(y, 4, f"... and {len(adds) - 5} more", curses.color_pair(3))
                y += 1
            y += 1
        
        if removes:
            dialog.addstr(y, 2, f"Will remove ({len(removes)}):", curses.color_pair(1) | curses.A_BOLD)
            y += 1
            for agent in removes[:5]:
                dialog.addstr(y, 4, f"- {agent}", curses.color_pair(1))
                y += 1
            if len(removes) > 5:
                dialog.addstr(y, 4, f"... and {len(removes) - 5} more", curses.color_pair(1))
                y += 1
        
        dialog.addstr(dialog_height - 2, 2, "Confirm? [y/n]", curses.A_BOLD)
        dialog.refresh()
        
        while True:
            key = dialog.getch()
            if key in [ord('s'), ord('S'), ord('y'), ord('Y')]:
                return True
            elif key in [ord('n'), ord('N'), 27]:
                return False
    
    def run(self, stdscr):
        """Main UI loop"""
        curses.curs_set(0)
        curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(4, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(5, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(6, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(7, curses.COLOR_WHITE, curses.COLOR_BLACK)
        
        while True:
            height, width = stdscr.getmaxyx()
            stdscr.clear()
            
            self.draw_header(stdscr, height, width)
            
            if self.current_view == View.SOURCES:
                self.draw_sources_view(stdscr, height, width)
                self.draw_sources_instructions(stdscr, height, width)
            elif self.current_view == "ADD_SOURCE":
                self.draw_add_source_form(stdscr, height, width)
            else:
                self.draw_tree(stdscr, height, width)
                self.draw_instructions(stdscr, height, width)
            
            stdscr.refresh()
            
            key = stdscr.getch()
            
            # Handle ADD_SOURCE form keys FIRST (before any other processing)
            if self.current_view == "ADD_SOURCE":
                if key == ord('\n'):  # Submit form
                    if self.process_add_source_form():
                        self.current_view = View.SOURCES
                elif key == curses.KEY_UP:
                    self.handle_add_form_navigation(key)
                elif key == curses.KEY_DOWN:
                    self.handle_add_form_navigation(key)
                elif key == 27:  # ESC
                    self.current_view = View.SOURCES
                    self.sources_status_messages.append("âœ— Add source cancelled")
                elif key == curses.KEY_BACKSPACE or key == 127 or key == 8:
                    self.handle_add_form_backspace()
                elif key == 22:  # Ctrl+V for paste
                    # Try to get clipboard content
                    try:
                        import subprocess
                        result = subprocess.run(['pbpaste'], capture_output=True, text=True)
                        if result.returncode == 0:
                            clipboard_text = result.stdout
                            for char in clipboard_text:
                                if 32 <= ord(char) <= 126:
                                    self.handle_add_form_typing(char)
                    except:
                        pass  # Clipboard not available
                elif 32 <= key <= 126:  # Printable characters
                    self.handle_add_form_typing(chr(key))
                    stdscr.refresh()  # Force immediate refresh
                continue  # Skip all other key processing for ADD_SOURCE mode
            
            # Navigation
            if key == curses.KEY_UP:
                if self.current_view == View.SOURCES:
                    self.handle_sources_navigation(key)
                else:
                    if self.current_index > 0:
                        self.current_index -= 1
            
            elif key == curses.KEY_DOWN:
                if self.current_view == View.SOURCES:
                    self.handle_sources_navigation(key)
                else:
                    if self.current_index < len(self.flattened_nodes) - 1:
                        self.current_index += 1
            
            elif key == curses.KEY_RIGHT or key == ord('\n'):
                # Expand folder
                if self.current_index < len(self.flattened_nodes):
                    node = self.flattened_nodes[self.current_index]
                    if node.is_folder and not node.expanded:
                        node.expanded = True
                        self.flatten_tree()
            
            elif key == curses.KEY_LEFT:
                # Collapse folder or go to parent
                if self.current_index < len(self.flattened_nodes):
                    node = self.flattened_nodes[self.current_index]
                    if node.is_folder and node.expanded:
                        node.expanded = False
                        self.flatten_tree()
                    elif node.parent and node.parent.level >= 0:
                        # Jump to parent folder
                        for i, n in enumerate(self.flattened_nodes):
                            if n == node.parent:
                                self.current_index = i
                                break
            
            # Space - toggle selection or expand/collapse folder
            elif key == ord(' '):
                if self.current_view == View.SOURCES:
                    self.handle_sources_navigation(key)
                else:
                    if self.current_index < len(self.flattened_nodes):
                        node = self.flattened_nodes[self.current_index]
                        if node.is_folder:
                            # Toggle expand/collapse for folders
                            node.toggle_expand()
                            self.flatten_tree()
                        else:
                            # Toggle selection for agents
                            self.toggle_selection(node)
            
            
            # View switching
            elif key == ord('1') and self.project_root:
                if self.current_view != View.PROJECT:
                    self.current_view = View.PROJECT
                    self.current_index = 0
                    self.load_installation_state()
                    self.flatten_tree()
                    # Force update of changes summary after view switch
                    self.update_all_changes_summary()
            
            elif key == ord('2'):
                if self.current_view != View.GENERAL:
                    self.current_view = View.GENERAL
                    self.current_index = 0
                    self.load_installation_state()
                    self.flatten_tree()
                    # Force update of changes summary after view switch
                    self.update_all_changes_summary()
            
            # View file
            elif key == ord('v') or key == ord('V'):
                if self.current_index < len(self.flattened_nodes):
                    node = self.flattened_nodes[self.current_index]
                    if not node.is_folder:
                        self.view_agent_file(node)
            
            # Save
            elif key == ord('s') or key == ord('S'):
                if self.current_view == View.SOURCES:
                    self.handle_sources_save_action()
                else:
                    if self.show_confirmation(stdscr, height, width):
                        self.save_changes()
            
            # Sources management (new)
            elif key == ord('g') or key == ord('G'):
                if self.current_view != View.SOURCES:
                    self.current_view = View.SOURCES
                    self.sources_index = 0
            
            # Handle additional sources navigation when in sources view
            elif self.current_view == View.SOURCES and key in [ord('a'), ord('A'), ord('d'), ord('D'), ord('u'), ord('U'), ord('y'), ord('Y')]:
                self.handle_sources_navigation(key)
            
            # Select all in current folder (not in Sources view or ADD_SOURCE)
            elif (key == ord('a') or key == ord('A')) and self.current_view not in [View.SOURCES, "ADD_SOURCE"]:
                if self.current_index < len(self.flattened_nodes):
                    current = self.flattened_nodes[self.current_index]
                    parent = current.parent if not current.is_folder else current
                    
                    for node in self.flattened_nodes:
                        if not node.is_folder and node.parent == parent:
                            node.selected = True
                            key = self.get_relative_key(node.path)
                            self.current_state[key] = True
                            if self.current_state[key] != self.original_state[key]:
                                self.changes[key] = 'add'
                            else:
                                self.changes[key] = None
                    
                    # Update changes summary
                    self.update_all_changes_summary()
            
            # Deselect all in current folder
            elif key == ord('n') or key == ord('N'):
                if self.current_index < len(self.flattened_nodes):
                    current = self.flattened_nodes[self.current_index]
                    parent = current.parent if not current.is_folder else current
                    
                    for node in self.flattened_nodes:
                        if not node.is_folder and node.parent == parent:
                            node.selected = False
                            key = self.get_relative_key(node.path)
                            self.current_state[key] = False
                            if self.current_state[key] != self.original_state[key]:
                                self.changes[key] = 'remove'
                            else:
                                self.changes[key] = None
                    
                    # Update changes summary
                    self.update_all_changes_summary()
            
            # Quit
            elif key == ord('q') or key == ord('Q'):
                adds, removes = self.get_changes_summary()
                if adds or removes:
                    if not self.show_confirmation(stdscr, height, width):
                        continue
                    else:
                        self.save_changes()
                break
            
            # ESC - cancel changes or exit sources view
            elif key == 27:
                if self.current_view == View.SOURCES:
                    self.current_view = View.GENERAL
                    self.current_index = 0
                else:
                    self.load_installation_state()
                    self.flatten_tree()
    
    def draw_sources_view(self, stdscr, height, width):
        """Draw the sources management view"""
        start_y = 6
        max_visible = height - 8
        
        sources = self.sources_manager.config.sources
        
        # Draw sources list
        for i, source in enumerate(sources):
            if i >= max_visible:
                break
                
            y_pos = start_y + i
            is_current = i == self.sources_index
            
            # Source status icon
            if source.enabled:
                status = "â—" if source.enabled else "â—‹"
                status_color = curses.color_pair(3) if source.enabled else curses.color_pair(6)
            else:
                status = "â—‹"
                status_color = curses.color_pair(6)
            
            # Priority indicator
            priority_text = f"[{source.priority:3d}]"
            
            # Source info
            sync_status = ""
            if source.last_sync:
                try:
                    last_sync = datetime.fromisoformat(source.last_sync.replace('Z', '+00:00'))
                    time_ago = datetime.now() - last_sync.replace(tzinfo=None)
                    if time_ago.days > 0:
                        sync_status = f" (synced {time_ago.days}d ago)"
                    elif time_ago.seconds > 3600:
                        sync_status = f" (synced {time_ago.seconds//3600}h ago)"
                    else:
                        sync_status = f" (synced {time_ago.seconds//60}m ago)"
                except:
                    sync_status = " (sync time unknown)"
            else:
                sync_status = " (never synced)"
            
            # Build display line
            source_line = f"{status} {priority_text} {source.name}"
            if len(source_line) > width - 20:
                source_line = source_line[:width-23] + "..."
            
            # Draw the line
            if is_current:
                stdscr.addstr(y_pos, 2, source_line, curses.color_pair(1) | curses.A_BOLD)
                # Show details on second line
                if y_pos + 1 < height - 3:
                    details = f"    {source.url}{sync_status}"
                    if len(details) > width - 4:
                        details = details[:width-7] + "..."
                    stdscr.addstr(y_pos + 1, 2, details, curses.color_pair(6))
            else:
                stdscr.addstr(y_pos, 2, status, status_color)
                stdscr.addstr(y_pos, 4, f"{priority_text} {source.name}")
        
        # Show status messages
        if self.sources_status_messages:
            msg_start_y = height - 6
            for i, msg in enumerate(self.sources_status_messages[-3:]):  # Show last 3 messages
                if msg_start_y + i < height - 3:
                    stdscr.addstr(msg_start_y + i, 2, msg[:width-4], curses.color_pair(4))
    
    def draw_sources_instructions(self, stdscr, height, width):
        """Draw sources view instructions"""
        stdscr.addstr(height - 2, 0, "â”€" * width, curses.color_pair(6))
        
        instructions = "[â†‘/â†“] Nav  [SPACE] Toggle  [a] Add  [d] Delete  [y] Sync one  [u] Sync all  [ESC] Back"
        
        if len(instructions) < width:
            stdscr.addstr(height - 1, 2, instructions[:width-3], curses.color_pair(6))
    
    def handle_sources_navigation(self, key):
        """Handle navigation in sources view"""
        sources_count = len(self.sources_manager.config.sources)
        
        if key == curses.KEY_UP:
            self.sources_index = max(0, self.sources_index - 1)
        elif key == curses.KEY_DOWN:
            self.sources_index = min(sources_count - 1, self.sources_index + 1)
        elif key == ord(' '):
            # Toggle source enabled/disabled
            if self.sources_index < sources_count:
                source = self.sources_manager.config.sources[self.sources_index]
                new_state = self.sources_manager.toggle_source(source.id)
                if new_state is not None:
                    status = "enabled" if new_state else "disabled"
                    self.sources_status_messages.append(f"Source '{source.name}' {status}")
        elif key == ord('a') or key == ord('A'):
            # Add new source - switch to form view
            self.current_view = "ADD_SOURCE"
            self.init_add_source_form()
        elif key == ord('d') or key == ord('D'):
            # Delete source
            if self.sources_index < sources_count:
                source = self.sources_manager.config.sources[self.sources_index]
                if source.id != "default":  # Protect default source
                    if self.sources_manager.remove_source(source.id):
                        self.sources_status_messages.append(f"Removed source '{source.name}'")
                        self.sources_index = min(self.sources_index, len(self.sources_manager.config.sources) - 1)
                else:
                    self.sources_status_messages.append("Cannot delete default source")
        elif key == ord('u') or key == ord('U'):
            # Update/sync ALL sources
            if not self.sync_in_progress:
                self.sync_sources_async()
        elif key == ord('y') or key == ord('Y'):
            # Sync only selected source
            if not self.sync_in_progress and self.sources_index < sources_count:
                source = self.sources_manager.config.sources[self.sources_index]
                self.sync_single_source_async(source.id)
        
        # Keep status messages manageable
        if len(self.sources_status_messages) > 10:
            self.sources_status_messages = self.sources_status_messages[-10:]
    
    def sync_single_source_async(self, source_id):
        """Sync a single source in background"""
        if self.sync_in_progress:
            return
        
        def progress_callback(message):
            self.sources_status_messages.append(message)
        
        def sync_thread():
            self.sync_in_progress = True
            source = next((s for s in self.sources_manager.config.sources if s.id == source_id), None)
            if source:
                self.sources_status_messages.append(f"Syncing {source.name}...")
                success = self.sources_manager.sync_source(source_id, progress_callback)
                
                if success:
                    self.sources_status_messages.append(f"âœ“ {source.name} synced successfully")
                    # Rebuild merged collection
                    try:
                        new_collection = self.sources_manager.get_merged_agents_collection()
                        if new_collection.exists():
                            self.agents_collection = new_collection
                            self.build_tree()
                            self.load_installation_state()
                            self.flatten_tree()
                            self.sources_status_messages.append("Agents collection refreshed")
                    except Exception as e:
                        self.sources_status_messages.append(f"Error refreshing collection: {e}")
                else:
                    self.sources_status_messages.append(f"âœ— Failed to sync {source.name}")
            else:
                self.sources_status_messages.append(f"Source not found: {source_id}")
            
            self.sync_in_progress = False
        
        # Run sync in background thread to not block UI
        thread = threading.Thread(target=sync_thread, daemon=True)
        thread.start()
    
    def sync_sources_async(self):
        """Sync ALL sources in background"""
        if self.sync_in_progress:
            return
        
        def progress_callback(message):
            self.sources_status_messages.append(message)
        
        def sync_thread():
            self.sync_in_progress = True
            self.sources_status_messages.append("Starting sync of all sources...")
            results = self.sources_manager.sync_all_sources(progress_callback)
            
            success_count = sum(1 for success in results.values() if success)
            total_count = len(results)
            
            self.sources_status_messages.append(f"Sync complete: {success_count}/{total_count} successful")
            
            # Reload agents collection if sync was successful
            if success_count > 0:
                try:
                    new_collection = self.sources_manager.get_merged_agents_collection()
                    if new_collection.exists():
                        self.agents_collection = new_collection
                        self.build_tree()
                        self.load_installation_state()
                        self.flatten_tree()
                        self.sources_status_messages.append("Agents collection refreshed")
                except Exception as e:
                    self.sources_status_messages.append(f"Error refreshing collection: {e}")
            
            self.sync_in_progress = False
        
        thread = threading.Thread(target=sync_thread, daemon=True)
        thread.start()
    
    def handle_sources_save_action(self):
        """Handle save action in sources view (sync all)"""
        if not self.sync_in_progress:
            self.sync_sources_async()
    
    def check_auto_sync_on_startup(self):
        """Check if auto-sync is needed on startup"""
        if not self.sources_manager.config.auto_sync:
            return
        
        now = datetime.now()
        last_sync = self.sources_manager.config.last_auto_sync
        
        should_sync = False
        
        if last_sync is None:
            # Never synced before
            should_sync = True
        else:
            try:
                last_sync_time = datetime.fromisoformat(last_sync.replace('Z', '+00:00')).replace(tzinfo=None)
                time_since_sync = now - last_sync_time
                
                if time_since_sync.total_seconds() > self.sources_manager.config.sync_interval:
                    should_sync = True
            except (ValueError, TypeError):
                # Invalid date format, sync to be safe
                should_sync = True
        
        if should_sync:
            self.sync_sources_startup_async()
    
    def sync_sources_startup_async(self):
        """Sync sources on startup in background"""
        def startup_sync_thread():
            self.sync_in_progress = True
            
            # Only sync if sources have content that needs updating
            enabled_sources = self.sources_manager.get_enabled_sources()
            if not enabled_sources:
                self.sync_in_progress = False
                return
            
            # Check if we have cached data first - if not, definitely sync
            needs_sync = False
            for source in enabled_sources:
                cache_path = self.sources_manager.get_source_cache_path(source.id)
                if not cache_path.exists():
                    needs_sync = True
                    break
            
            if needs_sync or True:  # Always sync on startup for now
                results = self.sources_manager.sync_all_sources()
                success_count = sum(1 for success in results.values() if success)
                
                if success_count > 0:
                    # Update last sync time
                    self.sources_manager.config.last_auto_sync = datetime.now().isoformat()
                    self.sources_manager.save_config()
                    
                    # Refresh collection if sync was successful
                    try:
                        new_collection = self.sources_manager.get_merged_agents_collection()
                        if new_collection.exists():
                            self.agents_collection = new_collection
                            # Note: We don't rebuild tree here to avoid UI disruption
                            # Tree will use new collection on next restart or manual refresh
                    except:
                        pass  # Silently fail to avoid startup disruption
            
            self.sync_in_progress = False
        
        # Run sync in background thread to not block UI startup
        thread = threading.Thread(target=startup_sync_thread, daemon=True)
        thread.start()
    
    def init_add_source_form(self):
        """Initialize add source form"""
        self.add_form_fields = {
            'url': '',
            'name': '',
            'priority': '50',
            'path': '.',  # Changed default to '.' for simpler local paths
            'type': 'git'
        }
        self.add_form_current_field = 0
    
    def handle_add_form_navigation(self, key):
        """Handle navigation in add form"""
        field_count = 5  # url, name, type, priority, path
        
        if key == curses.KEY_UP:
            self.add_form_current_field = max(0, self.add_form_current_field - 1)
        elif key == curses.KEY_DOWN:
            self.add_form_current_field = min(field_count - 1, self.add_form_current_field + 1)
    
    def handle_add_form_typing(self, char):
        """Handle typing in form fields"""
        field_names = ['url', 'name', 'type', 'priority', 'path']
        field_name = field_names[self.add_form_current_field]
        self.add_form_fields[field_name] += char
    
    def handle_add_form_backspace(self):
        """Handle backspace in form fields"""
        field_names = ['url', 'name', 'type', 'priority', 'path']
        field_name = field_names[self.add_form_current_field]
        if self.add_form_fields[field_name]:
            self.add_form_fields[field_name] = self.add_form_fields[field_name][:-1]
    
    def draw_add_source_form(self, stdscr, height, width):
        """Draw simplified add source form"""
        # Clear entire screen first
        stdscr.clear()
        
        # Header
        title = " Add Source "
        header_color = curses.color_pair(5)
        
        stdscr.addstr(0, 0, "â•”" + "â•" * (width-2) + "â•—", header_color | curses.A_BOLD)
        stdscr.addstr(1, 0, "â•‘", header_color | curses.A_BOLD)
        stdscr.addstr(1, width-1, "â•‘", header_color | curses.A_BOLD)
        stdscr.addstr(1, (width - len(title)) // 2, title, header_color | curses.A_BOLD)
        stdscr.addstr(2, 0, "â•š" + "â•" * (width-2) + "â•", header_color | curses.A_BOLD)
        
        # Form fields
        start_y = 4
        field_names = ['url', 'name', 'type', 'priority', 'path']
        field_labels = [
            'URL (Git repo or local path):',
            'Name (display name):',
            'Type (git/local):',
            'Priority (0-100):',
            'Path (subdirectory):'
        ]
        
        for i, (field_name, label) in enumerate(zip(field_names, field_labels)):
            y = start_y + i * 2
            
            # Field label
            stdscr.addstr(y, 2, label, curses.A_BOLD)
            
            # Field value
            field_value = self.add_form_fields.get(field_name, '')
            max_width = width - 10
            
            # Highlight current field
            if i == self.add_form_current_field:
                attr = curses.color_pair(1) | curses.A_REVERSE
                # Show cursor at end of text for active field
                display_value = field_value[-max_width+1:] if len(field_value) > max_width-1 else field_value
                field_display = display_value + "_"
            else:
                attr = curses.color_pair(6)
                display_value = field_value[:max_width]
                field_display = display_value
            
            # Clear the line first then draw field
            stdscr.addstr(y + 1, 4, " " * max_width, attr)
            stdscr.addstr(y + 1, 4, field_display[:max_width], attr)
        
        # Examples
        help_y = start_y + len(field_names) * 2 + 1
        if help_y < height - 4:
            stdscr.addstr(help_y, 2, "Examples:", curses.A_BOLD)
            stdscr.addstr(help_y + 1, 2, "Git: https://github.com/awesome-agents/collection.git", curses.color_pair(6))
            stdscr.addstr(help_y + 2, 2, "Local: /path/to/.claude/agents (type=local, path=.)", curses.color_pair(6))
            if help_y + 3 < height - 4:
                stdscr.addstr(help_y + 3, 2, "Note: For local sources, leave 'path' as '.' if URL points directly to agents", curses.color_pair(4))
        
        # Instructions
        instructions = "[â†‘/â†“] Navigate  [Type] Edit  [Ctrl+V] Paste  [ENTER] Submit  [ESC] Cancel"
        stdscr.addstr(height - 2, 2, instructions[:width-4], curses.color_pair(6))
    
    def validate_source_data(self, source_data):
        """Validate source data before adding"""
        errors = []
        
        # Check URL/path
        url = source_data['url']
        source_type = source_data['type']
        
        if source_type == 'local':
            # Check if local path exists
            if not Path(url).exists():
                errors.append(f"Local path does not exist: {url}")
        elif source_type == 'git':
            # Basic git URL validation
            if not (url.startswith('http://') or url.startswith('https://') or url.startswith('git@')):
                errors.append("Git URL should start with http://, https://, or git@")
        
        # Check name
        if not source_data['name']:
            errors.append("Name is required")
        
        # Check priority
        if not (0 <= source_data['priority'] <= 100):
            errors.append("Priority must be between 0 and 100")
        
        return {
            'valid': len(errors) == 0,
            'errors': errors
        }
    
    def generate_source_id(self, name):
        """Generate a unique source ID from name"""
        import re
        # Convert name to lowercase and replace spaces/special chars with hyphens
        source_id = re.sub(r'[^a-z0-9]+', '-', name.lower())
        source_id = source_id.strip('-')
        
        # Ensure uniqueness
        existing_ids = [s.id for s in self.sources_manager.config.sources]
        if source_id in existing_ids:
            counter = 1
            while f"{source_id}-{counter}" in existing_ids:
                counter += 1
            source_id = f"{source_id}-{counter}"
        
        return source_id
    
    def confirm_immediate_sync(self, source_name):
        """Ask if user wants to sync the new source immediately"""
        # For now, return False to skip immediate sync in non-interactive mode
        # Could be enhanced with a confirmation dialog
        return False
    
    def sync_source_immediate(self, source_id):
        """Sync a specific source immediately"""
        # This would trigger the sync process for the source
        # For now, just add a message
        self.sources_status_messages.append(f"Syncing source {source_id}...")
    
    def process_add_source_form(self):
        """Process add source form with validation"""
        # Basic validation
        if not self.add_form_fields['url'].strip():
            self.sources_status_messages.append("âœ— URL is required")
            return False
        
        if not self.add_form_fields['name'].strip():
            self.sources_status_messages.append("âœ— Name is required")
            return False
        
        # Prepare source data
        try:
            priority = int(self.add_form_fields['priority']) if self.add_form_fields['priority'].isdigit() else 50
        except:
            priority = 50
        
        # Handle path field - use '.' for local sources pointing directly to agents
        path_value = self.add_form_fields['path'].strip()
        if not path_value or path_value == '.':
            path_value = '.'
        elif path_value == 'agents-collection' and self.add_form_fields['type'].strip() == 'local':
            # If using default git path for local, change to '.'
            path_value = '.'
        
        source_data = {
            'url': self.add_form_fields['url'].strip(),
            'name': self.add_form_fields['name'].strip(),
            'type': self.add_form_fields['type'].strip() or 'git',
            'priority': priority,
            'path': path_value
        }
        
        # Validate
        validation_result = self.validate_source_data(source_data)
        
        if validation_result.get('valid', False):
            new_source = AgentSource(
                id=self.generate_source_id(source_data['name']),
                name=source_data['name'],
                url=source_data['url'],
                path=source_data['path'],
                priority=source_data['priority'],
                source_type=source_data['type'],
                enabled=True,
                readonly=True
            )
            
            if self.sources_manager.add_source(new_source):
                self.sources_status_messages.append(f"âœ“ Added source '{new_source.name}'")
                
                # Auto-sync new source
                if self.confirm_immediate_sync(new_source.name):
                    self.sync_source_immediate(new_source.id)
                
                return True
            else:
                self.sources_status_messages.append("âœ— Failed to add source (ID conflict)")
        else:
            # Show validation errors
            for error in validation_result.get('errors', []):
                self.sources_status_messages.append(f"âœ— {error}")
        
        return False

def main():
    """Main entry point"""
    try:
        manager = AgentManagerTree()
        curses.wrapper(manager.run)
        print("\nGoodbye!")
    except KeyboardInterrupt:
        print("\nGoodbye!")
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
